# Gateway

This sets up the gateway (with NAT) for a pocket network using dnsmasq for DNS, TFTP, and DHCP.  It's expected the hosts on the pocket network are Raspberry Pi machines versions 3 or 4 and primarily running k3os.

Also, the host the script is run on needs to be on the same network that the external interface on the firewall gateway is on.

## Executing this script

Install rundoc, execute rundoc to extract the script embedded in this README, edit configuration in vars.sh, the run the gateway install script.

```usage
pip3 install rundoc
rundoc run -a README.md
gateway.sh
```


## Header 

The vars below will be templated to vars.sh and will be sourced by `gateway.sh`.  This vars file can be edited after it's generated by README.md.

If DEVICE is empty, then `gateway.sh` will suggest USB block devices that can be used.  The external device is for the gateway and should have access to the gateway to internet, acceptable values are eth0 and wlan0, eth1 on USB is expected to be the pocket network.

The WIFI configuration will be for wlan0, if connecting via eth0, 
```r-create-file:gateway/vars.sh#files
DEVICE=%:DEVICE:%
EXTERNAL_DEVICE=%:EXTERNAL_DEVICE:%
WIFI_SSID=%:WIFI_SSID:%
WIFI_PASSWORD=%:WIFI_PASSWORD:%
```

For gateway, make sure we fail on errors and load the vars.
```bash
#!/bin/bash

set -euo pipefail

source gateway/vars.sh
```


## Download

Download raspberry pi boot firmware and kernel

```bash
FIRMWARE_ARCHIVE=firmware_master.tgz
[[ ! -f "$FIRMWARE_ARCHIVE" ]] && wget -O "$FIRMWARE_ARCHIVE" https://github.com/raspberrypi/firmware/archive/master.tar.gz
```

Pull ubuntu preinstalled server, which is a compacted complete disk image

```bash
wget --no-clobber http://cdimage.ubuntu.com/releases/18.04.4/release/ubuntu-18.04.4-preinstalled-server-armhf+raspi3.img.xz
```

```bash
version=1.31.1
BUSYBOX=busybox-$version.tar.bz2
wget --no-clobber "https://www.busybox.net/downloads/$BUSYBOX"
tar --bzip2 -xf "$BUSYBOX"
tar -zcf busybox.tgz busybox-$version
```

## Install

Find SD Card (check is for USB devices: not generic, sorry)

```bash
if [[ "${DEVICE:-}" == "" ]]; then
    DEVICES="$(ls /sys/bus/usb/devices/*/*/host*/target*/*/block)"
    echo -e "\nFound devices: $DEVICES\n"
    echo -e "usage: env DEVICE=<device name e.g. sdb> $0\n"
    exit 1
fi
```

make sure that filesystems are not mounted

```bash
foundParts=$(lsblk -J "/dev/$DEVICE" | jq ".blockdevices[].children|length")
if [[ "$foundParts" != "0" ]]; then
  echo -e "Found filesystems, please umount filesystems and clear SD card partition table:\n$(lsblk --fs /dev/"$DEVICE")"
  echo -e "\nThis command will wipe the partition table:"
  echo -e "sudo dd if=/dev/zero of=\"/dev/$DEVICE\" bs=1M count=5\n" 
  exit 1
fi
```

Unpack ubuntu onto the selected device

```bash
xzcat --stdout ubuntu-18.04.4-preinstalled-server-armhf+raspi3.img.xz | pv | sudo dd of=/dev/$DEVICE bs=1M
sudo partprobe
```

Mount the ubuntu partitions

```bash
PIROOT=/media/$USER/piroot
sudo mkdir -p /media/$USER/piboot "$PIROOT"
sudo mount /dev/${DEVICE}1 /media/$USER/piboot
sudo mount /dev/${DEVICE}2 "$PIROOT"
```

## Network Interfaces

Set up interfaces.  `eth0` is connected to external network, while the pocket network will be on USB on `eth1`, raspberry pi 4 would have much better network speeds than earlier versions.

```create-file:gateway/eth0.yaml#files
network:
    version: 2
    renderer: networkd
    ethernets:
        eth0:
            optional: true
            dhcp4: false
            addresses: [192.168.3.1/24]
            # no gateway, we don't want this host to route over the pocket
            nameservers:
                    search: [k8s.local]
                    addresses: [192.168.3.1, 1.1.1.1]
```

Interface for external network as DHCP
```create-file:gateway/eth1.yaml#files
network:
    version: 2
    renderer: networkd
    ethernets:
        eth1:
            optional: true
            dhcp4: true
```

Example for wireless network for external interface

```r-create-file:gateway/wlan0.yaml#files
network:
    version: 2
    renderer: networkd
    wifis:
        wlan0:
            # allow OS to start (while still building boot sequeuence)
            optional: true
            # do not release IP address
            critical: true
            dhcp4: true
            access-points:
                "%:WIFI_SSID:%":
                    password: "%:WIFI_PASSWORD:%"
```

Copy the network files (adjust as needed prior to running gateway.sh)

```bash
pushd "$PIROOT"/etc/netplan
sudo cp ~1/gateway/{wlan0,eth{0,1}}.yaml .
popd
```

I forget why we do this, think it's to avoid cloud init from conflicting from our manual setup of netplan
```create-file:gateway/cloud-init/disable-network-config.cfg#files
network: {config: disabled}
```

Copy the configuration files
```bash
pushd "$PIROOT"/etc/cloud/cloud.cfg.d
sudo cp ~1/gateway/cloud-init/disable-network-config.cfg 99-disable-network-config.cfg
popd
```


## Hostname resolution

Set the hostname

```create-file:gateway/cloud-init/hostname.cfg#files
hostname: infra1
```

Turn off systemd DNS stub so dnsmasq can listen 
```create-file:gateway/resolved.conf#files
echo DNSStubListener=no
```

Copy the configuration files to mounted ubuntu filesystem
```bash
pushd $PIROOT/etc
sudo cp ~1/gateway/resolved.conf systemd/resolved.conf
sudo cp ~1/gateway/cloud-init/hostname.cfg cloud/cloud.cfg.d/99-hostname.cfg
popd
```


## SSH

Add ssh keys

```bash
if ! ls ~/.ssh/id_*.pub; then
  echo No ssh keys in ~/.ssh
fi

pushd "$PIROOT"/etc/cloud/cloud.cfg.d
echo "ssh_authorized_keys:" | sudo tee 99-ssh_authorized_keys.cfg 2>/dev/null
for f in $(ls ~/.ssh/id_*.pub); do
  echo "  - $(cat $f)" | sudo tee -a 99-ssh_authorized_keys.cfg 2>/dev/null
done
popd

```

## Packages

```create-file:gateway/cloud-init/packages.cfg#files
packages:
  - dnsmasq
  - rng-tools
  - make
  - gcc
  - iptables-persistent
  - netfilter-persistent
  - iptables-persistent
  - netfilter-persistent
```

Copy the configuration files
```bash
pushd "$PIROOT"/etc/cloud/cloud.cfg.d
sudo cp ~1/gateway/cloud-init/packages.cfg 99-packages.cfg
popd
```


## Firewall

This is not firewalling, it's just forwarding packets with NAT currently.

NAT the forwarded packets
```r-create-file:gateway/rules.v4#files
*filter
:INPUT ACCEPT [1777:151380]
:FORWARD ACCEPT [4:336]
:OUTPUT ACCEPT [1853:3675835]
COMMIT
*nat
:PREROUTING ACCEPT [6:1474]
:INPUT ACCEPT [5:1390]
:OUTPUT ACCEPT [4:301]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -o %:EXTERNAL_DEVICE:% -j MASQUERADE
COMMIT
```

Enable forwarding and provide iptables config on startup

```bash
pushd "$PIROOT"/etc
sudo sed -i 's/^#net.ipv4.ip_forward/net.ipv4.ip_forward/' sysctl.conf
sudo mkdir -p iptables
sudo cp ~1/gateway/rules.v4 iptables/
popd
```


## dnsmasq

DNS and DHCP will be configured on eth1 for the pocket network, and provide a DNS server on eth0 and wlan0 to optionally provide DNS for the external network.

```create-file:gateway/dnsmasq/pocket.conf#files
listen-address=192.168.3.1
# default is 150
cache-size=1000
no-dhcp-interface=eth0
no-dhcp-interface=wlan0
domain=k8s.local
# gateway
dhcp-option=3,0.0.0.0
# dns servers
dhcp-option=6,192.168.3.1
# static route
dhcp-option=121,0.0.0.0/0,192.168.3.1
dhcp-range=192.168.3.150,192.168.3.250,5m
log-dhcp
enable-tftp
tftp-root=/tftpboot
pxe-service=0,"Raspberry Pi Boot   "
bogus-priv
domain-needed
# have a special resolve configuration that dnsmasq uses
# which allows system to point to external network dns
resolv-file=/etc/resolv.dnsmasq.conf
addn-hosts=/etc/hosts.dnsmasq
```

```create-file:gateway/dnsmasq/hosts#files
192.168.3.1 infra1
```

```create-file:gateway/dnsmasq/resolv.conf#files
nameserver 1.1.1.1
options edns0
search k8s.local
```

Copy the configuration files
```bash
pushd "$PIROOT"/etc
sudo cp ~1/gateway/dnsmasq/pocket.conf dnsmasq.d/pocket
sudo cp ~1/gateway/dnsmasq/hosts hosts.dnsmasq
sudo cp ~1/gateway/dnsmasq/resolv.conf resolv.dnsmasq.conf
popd
```


## Raspi Specific Boot

#### Firmware and Kernel

Also in the downloaded firmware there is a kernel that can work for netboot as it has statically compiled device drivers

```bash
pushd "$PIROOT"
sudo mkdir -p tftpboot
sudo tar -C tftpboot  --strip-components=2 -zxf ~1/"$FIRMWARE_ARCHIVE" firmware-master/boot
popd
```

#### Load kernel and initramfs

Loads the initramfs right after the kernel and sets it up so kernel uses it
```bash
pushd "$PIROOT"
cat > tftpboot/config.txt <<EOF
initramfs initramfs.img followkernel
framebuffer_width=800
framebuffer_height=480
EOF
popd
```


## Installer


The installer is composed of two parts, a kernel and a initramfs which is a filesystem loaded into ram instead of read off disk.  Both of these will be delivered over tftp during netboot.  The initramfs filesystem will be binaries provided by busybox, as it only needs limited features to perform the installation.

### Busybox
The busybox binary needs to be compiled on the pi to be the correct architecture. Since the local machine is often not a raspi, this will be done as part of first time boot of the raspi gateway and placed into the tftp directory to be available to raspis being booted.

This is the beginning of a script run at first boot to unpack the archive in /root and compile busybox.

```create-file:gateway/first-boot/busybox-compile-and-install.sh#files
#!/bin/bash

set -euo pipefail

mkdir -p busybox
tar -C busybox --strip-components 1 -zxvf /root/busybox.tgz
cd busybox
make defconfig
LDFLAGS="--static" make -j2
```

To create the initramfs, a working directory will be created and busybox installation will target the work directory and create symlinks to busybox for all the binaries it replaces.

```append-file:gateway/first-boot/busybox-compile-and-install.sh#files
mkdir /root/bbroot
LDFLAGS="--static" make install CONFIG_PREFIX=/root/bbroot
```

Copy the busybox script and the busybox archive to the sd card so it's available for first boot compile and install.

```bash
chmod 755 gateway/first-boot/busybox-compile-and-install.sh
sudo cp busybox.tgz gateway/first-boot/busybox-compile-and-install.sh "$PIROOT/root"
```

### gateway first boot to create initramfs

The initramfs sets up networking and does installation within an init script.  Busybox installed an init script, we need to replace it.  The creation of the initramfs is run during first boot of the gateway.

The initramfs goal is to run an install script.  The install script itself is a download from the gateway as it's easier to modify the install script on the gateway outside of the initramfs.

#### init scripts - configuring DHCP interface

To be able to download the script, networking must be set up.  To set up networking udhcpc runs a script with environment variables as inputs which can be used to configure the interface.

```create-file:installer/udhcpc-configure-interface.sh#files
# not starting new shell as the dhcp variables are not exported

# can source this in other scripts
set +x
env > /etc/dhcp.env

if [[ "$1" != "bound" ]]; then
    echo DHCP interface not bound ...
    exit 0
fi
ip addr add $ip/$mask dev $interface
ip route add default via $router dev $interface
echo nameserver $dns > /etc/resolv.conf
echo Networking is configured
if tftp -g -l /root/install.sh -r install.sh $router 2>/dev/null; then
    chmod 744 /root/install.sh
    echo Install script retrieved
else
    echo No install.sh found
fi
```

This init script allows a second init script to behave like a normal script

```create-file:installer/init#files
#!/bin/sh
set -euo pipefail

mount -t proc none /proc
mount -t sysfs none /sys
echo /sbin/mdev > /proc/sys/kernel/hotplug
mknod /dev/null c 1 3
/sbin/mdev -s
exec setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1 /sbin/init2'
```

This script downloads and installs the install script.  

```create-file:installer/init2#files
#!/bin/sh

# keep the kernel messages from appearing on screen
echo 0 > /proc/sys/kernel/printk

# bring link up after we wait a second for it to appear so DHCP client can send packets
sleep 1
ip link set dev eth0 up

echo Starting udhcpc
if udhcpc; then
    [ -x /root/install.sh ] && /root/install.sh && reboot -f
fi
/bin/ash
```

Copy the init scripts to sd card so can be used during first boot
```bash
sudo cp installer/init{,2} "$PIROOT"/root/
```

#### create initramfs image

Prepare all the items needed for the kernel and some glibc libs that can't be statically compiled in busybox for dns.

```create-file:installer/initramfs.sh#files
#!/bin/bash
set -euo pipefail

cd /root/bbroot
mkdir -p {proc,sys,dev,etc,usr/lib,bin,sbin,lib/arm-linux-gnueabihf}
sudo cp /lib/arm-linux-gnueabihf/libnss* lib/arm-linux-gnueabihf/
```

overwrite the busybox init script in the initramfs directory and copy init2 and the dhcp configuration script
```append-file:installer/initramfs.sh#files
rm sbin/init
cp /root/init{,2}  sbin/
mkdir -p usr/share/udhcpc
cp /root/udhcpc-configure-interface.sh usr/share/udhcpc/default.script
sudo chmod 744 sbin/init sbin/init2 usr/share/udhcpc/default.script
```

Create the initramfs to tftpboot dir
```append-file:installer/initramfs.sh#files
find . | cpio -H newc -o | gzip > /tftpboot/initramfs.img
```

```create-file:gateway/first-boot/run-cmd.cfg#files
runcmd:
  - /root/busybox-compile-and-install.sh
  - /root/initramfs.sh
```

This cloud init fragment will run the first time boot scripts to create the initramfs

Copy the script to create the initramfs to the sd card for reference by first boot
```bash
sudo chmod 755 installer/{udhcpc-configure-interface.sh,initramfs.sh}
sudo cp installer/{udhcpc-configure-interface.sh,initramfs.sh} "$PIROOT"/root/
```

Copy the cloud init configuration to the sd card
```bash
sudo cp gateway/first-boot/run-cmd.cfg "$PIROOT"/etc/cloud/cloud.cfg.d/99-run-cmd.cfg
```

## Install script


```create-file:installer/install.sh#files
#!/bin/ash

set -e

source /etc/dhcp.env

echo RUNNING INSTALL

image=ubuntu-18.04.4-preinstalled-server-armhf+raspi3.img.xz
tftp -g -r "$image" $router

zcat $image | dd of=/dev/mmcblk0 bs=1M

partprobe

mkdir -p /mnt
mkdir -p boot
mount /dev/mmcblk0p1 boot
mount /dev/mmcblk0p2 /mnt

#wget -O - https://github.com/rancher/k3os/releases/download/v0.9.0/k3os-rootfs-arm.tar.gz | tar zxvf - --strip-components=1 -C /mnt

cat >> boot/config.txt <<EOF
framebuffer_width=800
framebuffer_height=480

#arm_64bit=1
EOF

#cat  > boot/cmdline.txt <<EOF
#root=/dev/mmcblk0p2 init=/sbin/init rw rootwait elevator=deadline
#EOF

# if 64 bit, remember to update config.txt with arm_64bit=1 and use kernel8.img instead of kernel7l.img
#tftp -g -l boot/kernel7.img -r vmlinuz-5.3.0-1018-raspi2 $router

sync

umount boot /mnt

echo Successful Installation
```

copy the install script, and OS images
```bash
pushd "$PIROOT"/tftpboot/
sudo cp ~1/installer/install.sh .
sudo cp ~1/ubuntu-18.04.4-preinstalled-server-armhf+raspi3.img.xz .
popd
```

## Complete

Unmount the sd card partitions

```bash
sync
sudo umount /dev/${DEVICE}1 /dev/${DEVICE}2
sudo eject /dev/${DEVICE}
```

## Notes

Manually update network interface configuration by editing files in `/etc/netplan`

```
sudo netplan generate
sudo netplan apply
```

## Troubleshooting

- 7 green blinks mean kernel is not found
- ubuntu kernel probably has some of the support as modules and needs matching initramfs

## Further Reading

https://www.raspberrypi.org/documentation/configuration/config-txt/README.md
